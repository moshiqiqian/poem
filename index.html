<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古诗词资源库 - 墨香雅韵</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Noto Serif SC', 'Inter', serif;
            background-color: #f7f3ed; /* 淡米色背景，模仿宣纸 */
            color: #3f3f3f; /* 深灰色文本 */
        }
        .card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        .text-classical {
            font-family: 'Noto Serif SC', serif;
        }
        .view {
            display: none;
        }
        .active {
            display: block;
        }
        /* 关系图谱样式 */
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        .relationship-svg {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background-color: white;
        }
    </style>
</head>
<body class="min-h-screen">
    
    <header class="bg-red-700 shadow-md">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <h1 class="text-3xl font-bold text-white text-classical">墨香雅韵：古诗词资源库</h1>
            <nav class="space-x-4">
                <button onclick="changeView('list-view')" class="text-white hover:text-red-300 font-semibold transition duration-150 text-lg">诗词列表</button>
                <button onclick="changeView('relationship-view')" class="text-white hover:text-red-300 font-semibold transition duration-150 text-lg">关系图谱</button>
            </nav>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-10">

        <div id="list-view" class="view active">
            <h2 class="text-3xl font-semibold mb-6 border-b pb-2 text-classical">古诗词列表</h2>
            
            <form id="search-form" class="mb-4 flex space-x-4">
                <input type="text" id="search-query" placeholder="搜索诗人、朝代、诗名..." class="flex-grow px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-red-500">
                <button type="submit" class="bg-red-700 text-white px-6 py-2 rounded-lg font-semibold hover:bg-red-800 transition duration-150">搜索</button>
            </form>
            
            <div id="search-status-container" class="mb-6 hidden">
                <span class="bg-red-100 text-red-800 text-sm font-medium mr-2 px-3 py-1 rounded-full flex items-center w-fit">
                    当前筛选关键词：<span id="current-search-query" class="font-bold ml-1"></span>
                    <button id="clear-search-btn" class="ml-2 text-red-600 hover:text-red-900 focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </span>
            </div>
            
            <div id="poem-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                </div>
        </div>

        <div id="detail-view" class="view">
            <button onclick="changeView('list-view')" class="mb-6 text-red-700 hover:text-red-900 font-semibold flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                </svg>
                返回列表
            </button>
            <div id="poem-detail-card" class="bg-white p-8 rounded-xl shadow-lg text-classical">
                <h2 id="detail-title" class="text-4xl font-bold mb-2 text-red-800"></h2>
                <p id="detail-meta" class="text-gray-600 mb-6 text-lg"></p>
                <div id="detail-content" class="whitespace-pre-wrap leading-relaxed text-xl border-t pt-6"></div>
            </div>

            <div class="mt-10 p-8 bg-white rounded-xl shadow-lg">
                <h3 class="text-2xl font-semibold mb-6 border-b pb-2 text-classical">评论区</h3>
                <form id="comment-form" class="mb-8 p-4 border rounded-lg bg-gray-50">
                    <input type="hidden" id="comment-poem-id">
                    <textarea id="comment-content" placeholder="发表你的见解或评论..." rows="4" class="w-full p-3 border rounded-lg focus:outline-none focus:border-red-500 mb-3 text-classical"></textarea>
                    <div class="flex justify-between items-center">
                        <input type="text" id="comment-username" placeholder="你的名字 (可选)" class="px-3 py-2 border rounded-lg w-1/4 text-classical">
                        <button type="submit" class="bg-red-700 text-white px-6 py-2 rounded-lg font-semibold hover:bg-red-800 transition duration-150">提交评论</button>
                    </div>
                </form>

                <div id="comments-container" class="space-y-4">
                    </div>
            </div>
        </div>

        <div id="relationship-view" class="view">
            <h2 class="text-3xl font-semibold mb-6 border-b pb-2 text-classical">诗人关系图谱 (D3 Force Graph)</h2>
            <div id="relationship-chart" class="relationship-svg w-full" style="height: 700px;">
                <p class="text-center text-gray-500 pt-6">正在加载图谱数据...</p>
            </div>
        </div>
        
    </main>

    <div id="message-container" class="fixed bottom-4 right-4 space-y-2">
        </div>

    <script>
        const API_BASE_URL = 'http://localhost:3000/api';

        // --- 1. 视图切换 ---
        function changeView(viewId) {
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            document.getElementById(viewId).classList.add('active');

            // 如果切换到关系图谱，确保数据已加载
            if (viewId === 'relationship-view') {
                fetchRelationships();
            }
        }

        // --- 2. 消息提示 ---
        function showMessage(msg, type = 'info') {
            const container = document.getElementById('message-container');
            const alert = document.createElement('div');
            
            let color = 'bg-blue-500';
            if (type === 'success') color = 'bg-green-500';
            if (type === 'error') color = 'bg-red-500';

            alert.className = `${color} text-white px-4 py-3 rounded-lg shadow-xl text-sm opacity-0 transition-opacity duration-300`;
            alert.textContent = msg;

            container.appendChild(alert);

            // 动画显示
            setTimeout(() => {
                alert.classList.remove('opacity-0');
                alert.classList.add('opacity-100');
            }, 10); 

            // 自动消失
            setTimeout(() => {
                alert.classList.remove('opacity-100');
                alert.classList.add('opacity-0');
                setTimeout(() => alert.remove(), 300);
            }, 5000);
        }
        
        // --- 3. 评论渲染 (递归渲染回复) ---
        function renderComments(comments) {
            const container = document.getElementById('comments-container');
            container.innerHTML = '';
            
            // 1. 构建树形结构 (通过 parentID)
            const commentMap = {};
            const rootComments = [];
            comments.forEach(c => {
                commentMap[c.id] = {...c, replies: []};
                if (c.parentID === null) {
                    rootComments.push(commentMap[c.id]);
                }
            });

            comments.forEach(c => {
                if (c.parentID !== null && commentMap[c.parentID]) {
                    commentMap[c.parentID].replies.push(commentMap[c.id]);
                }
            });

            // 2. 递归渲染函数
            const renderCommentNode = (comment, level = 0) => {
                const commentDiv = document.createElement('div');
                let paddingClass = level > 0 ? 'ml-6 pl-4 border-l border-gray-200' : '';
                
                commentDiv.className = `p-4 rounded-lg bg-gray-50 ${paddingClass}`;
                commentDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <span class="font-semibold text-red-700">${comment.username}</span>
                        <span class="text-xs text-gray-500">${new Date(comment.createdAt).toLocaleDateString()} ${new Date(comment.createdAt).toLocaleTimeString()}</span>
                    </div>
                    <p class="text-gray-800 text-classical">${comment.content}</p>
                    <button class="reply-button text-xs text-red-500 hover:text-red-700 mt-1" data-id="${comment.id}" data-username="${comment.username}">回复</button>
                    <div id="replies-of-${comment.id}" class="mt-3 space-y-3"></div>
                `;
                
                // 添加回复框的逻辑
                commentDiv.querySelector('.reply-button').onclick = (e) => {
                    const parentID = e.target.dataset.id;
                    const parentUser = e.target.dataset.username;
                    const existingForm = document.getElementById(`reply-form-${parentID}`);
                    
                    // 如果回复表单已存在，则移除
                    if (existingForm) {
                        existingForm.remove();
                        e.target.textContent = '回复'; // 恢复按钮文本
                        return;
                    }
                    
                    // 移除所有已存在的回复表单
                    document.querySelectorAll('[id^="reply-form-"]').forEach(form => form.remove());
                    document.querySelectorAll('.reply-button').forEach(btn => btn.textContent = '回复');

                    // 创建新的回复表单
                    const replyForm = document.createElement('form');
                    replyForm.id = `reply-form-${parentID}`;
                    replyForm.className = 'mt-3 p-3 border rounded-lg bg-white';
                    replyForm.innerHTML = `
                        <input type="hidden" id="reply-poem-id-${parentID}" value="${document.getElementById('comment-poem-id').value}">
                        <input type="hidden" id="reply-parent-id-${parentID}" value="${parentID}">
                        <textarea id="reply-content-${parentID}" placeholder="回复 @${parentUser}: " rows="2" class="w-full p-2 border rounded-lg focus:outline-none focus:border-red-500 mb-2 text-classical"></textarea>
                        <div class="flex justify-end">
                            <input type="text" id="reply-username-${parentID}" placeholder="你的名字 (可选)" class="px-2 py-1 border rounded-lg w-1/4 mr-2 text-sm text-classical">
                            <button type="submit" class="bg-red-600 text-white px-4 py-1 rounded-lg font-semibold hover:bg-red-700 transition duration-150 text-sm">提交回复</button>
                        </div>
                    `;
                    
                    // 提交回复事件
                    replyForm.addEventListener('submit', (event) => submitComment(event, parentID, true));
                    
                    commentDiv.appendChild(replyForm);
                    e.target.textContent = '取消回复'; // 更改按钮文本
                };


                // 递归渲染子回复
                const repliesContainer = commentDiv.querySelector(`#replies-of-${comment.id}`);
                comment.replies.forEach(reply => {
                    repliesContainer.appendChild(renderCommentNode(reply, level + 1));
                });

                return commentDiv;
            };

            // 3. 将根评论添加到主容器
            if (rootComments.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500">暂无评论，快来抢沙发吧！</p>';
            } else {
                rootComments.forEach(comment => {
                    container.appendChild(renderCommentNode(comment));
                });
            }
        }
        
        // --- 4. 数据获取与渲染：诗词列表 (支持搜索) ---

        /**
         * 渲染古诗词列表
         * @param {PoemResult[]} poems 
         */
        function renderPoemList(poems) {
            const listContainer = document.getElementById('poem-list');
            // 核心：清空旧列表，渲染新列表
            listContainer.innerHTML = ''; 

            poems.forEach(poem => {
                const card = document.createElement('div');
                card.className = 'bg-white p-6 rounded-xl card hover:shadow-lg transition duration-300 cursor-pointer text-classical';
                card.innerHTML = `
                    <h3 class="text-xl font-bold mb-2 text-red-700">${poem.title}</h3>
                    <p class="text-gray-600 mb-3 text-sm">${poem.dynasty} · **${poem.author}**</p>
                    <p class="text-gray-700 italic line-clamp-3">${poem.content}...</p>
                `;
                card.onclick = () => fetchPoemDetail(poem.id);
                listContainer.appendChild(card);
            });
            // 如果没有诗词，显示提示
            if (poems.length === 0) {
                listContainer.innerHTML = '<p class="col-span-full text-center text-gray-500">未找到符合条件的古诗词。</p>';
            }
        }

        /**
         * 获取古诗词列表，支持搜索查询
         * @param {string} [query=''] - 搜索关键词
         */
        async function fetchPoems(query = '') {
            try {
                // 构建带搜索参数的 URL
                const url = query 
                    ? `${API_BASE_URL}/poems?search=${encodeURIComponent(query)}` 
                    : `${API_BASE_URL}/poems`;
                    
                const response = await fetch(url);
                const result = await response.json();

                if (result.code === 200) {
                    // **核心：调用 renderPoemList 刷新列表**
                    renderPoemList(result.data);
                    
                    // 【搜索后的效果反馈】
                    const statusContainer = document.getElementById('search-status-container');
                    const currentQuerySpan = document.getElementById('current-search-query');
                    const searchInput = document.getElementById('search-query');
                    
                    if (query) {
                        // 1. 显示筛选状态
                        statusContainer.classList.remove('hidden');
                        currentQuerySpan.textContent = query;
                        showMessage(`搜索完成，找到 ${result.data.length} 首诗词。`, 'success');
                        // 2. 清空搜索框（优化用户体验）
                        searchInput.value = ''; 
                    } else {
                        // 3. 隐藏筛选状态（如果query为空，表示是全量加载）
                        statusContainer.classList.add('hidden');
                        // 只有在用户主动清除搜索时才显示提示
                        if (currentQuerySpan.textContent) {
                            showMessage('已清除搜索条件，显示全部列表。', 'info');
                        }
                    }
                    
                } else {
                    showMessage(`获取列表失败: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Fetch poems failed:', error);
                showMessage('网络错误，无法连接到后端服务。', 'error');
            }
        }


        // --- 5. 数据获取与渲染：诗词详情与评论 ---

        async function fetchPoemDetail(id) {
            try {
                const detailResponse = await fetch(`${API_BASE_URL}/poem/${id}`);
                const detailResult = await detailResponse.json();

                if (detailResult.code === 200) {
                    const poem = detailResult.data;
                    document.getElementById('detail-title').textContent = poem.title;
                    document.getElementById('detail-meta').textContent = `${poem.dynasty} · ${poem.author}`;
                    document.getElementById('detail-content').textContent = poem.content;
                    document.getElementById('comment-poem-id').value = poem.id; // 填充评论表单的ID
                    
                    await fetchComments(id);
                    changeView('detail-view');
                } else {
                    showMessage(`获取详情失败: ${detailResult.message}`, 'error');
                }
            } catch (error) {
                console.error('Fetch poem detail failed:', error);
                showMessage('网络错误，无法获取诗词详情。', 'error');
            }
        }

        async function fetchComments(poemID) {
            try {
                const response = await fetch(`${API_BASE_URL}/comments/${poemID}`);
                const result = await response.json();

                if (result.code === 200) {
                    renderComments(result.data);
                } else {
                    showMessage(`获取评论失败: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Fetch comments failed:', error);
                // 即使失败也继续显示页面，只在评论区给出提示
                document.getElementById('comments-container').innerHTML = '<p class="text-center text-red-500">评论加载失败。</p>';
            }
        }

        // --- 6. 评论提交 ---

        async function submitComment(event, parentID = null, isReply = false) {
            event.preventDefault();
            
            let poemID, content, username;

            if (isReply && parentID) {
                poemID = document.getElementById(`reply-poem-id-${parentID}`).value;
                content = document.getElementById(`reply-content-${parentID}`).value.trim();
                username = document.getElementById(`reply-username-${parentID}`).value.trim() || '匿名用户';
            } else {
                poemID = document.getElementById('comment-poem-id').value;
                content = document.getElementById('comment-content').value.trim();
                username = document.getElementById('comment-username').value.trim() || '匿名用户';
            }
            
            if (!content) {
                showMessage('评论内容不能为空！', 'error');
                return;
            }

            const payload = {
                poemID: parseInt(poemID),
                content,
                username,
                parentID: parentID ? parseInt(parentID) : null
            };

            try {
                const response = await fetch(`${API_BASE_URL}/comments`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.code === 201) {
                    showMessage('评论发表成功！', 'success');
                    
                    // 清空表单
                    if (isReply && parentID) {
                        document.getElementById(`reply-content-${parentID}`).value = '';
                        // 移除回复框
                        document.getElementById(`reply-form-${parentID}`).remove();
                        document.querySelector(`[data-id="${parentID}"]`).textContent = '回复'; // 恢复按钮文本
                    } else {
                        document.getElementById('comment-content').value = '';
                    }

                    // 重新加载评论
                    await fetchComments(poemID);
                } else {
                    showMessage(`评论失败: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Submit comment failed:', error);
                showMessage('网络错误，评论发表失败。', 'error');
            }
        }


        // --- 7. D3 关系图谱渲染 ---
        
        // ... (保持不变：D3相关函数) ...

        function renderRelationshipGraph(data) {
            const container = d3.select("#relationship-chart");
            container.selectAll("*").remove(); // 清除旧图表内容

            const width = container.node().clientWidth;
            const height = 700;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const nodes = data.nodes;
            const links = data.links;
            
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked);

            // 定义颜色比例尺
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // 绘制连线
            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke-width", d => Math.sqrt(d.value))
                .attr("class", "link");

            // 绘制节点 (包含圆圈和文本)
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(drag(simulation));

            // 添加节点圆圈
            node.append("circle")
                .attr("r", 8)
                .attr("fill", d => colorScale(d.group)); 

            // 添加节点标签 (诗人姓名)
            node.append("text")
                .text(d => d.id)
                .attr('x', 10)
                .attr('y', 3)
                .attr('fill', '#3f3f3f')
                .attr('font-size', '12px');

            // 关系描述 tooltip
            link.append("title")
                .text(d => `${d.source.id} — ${d.relation} — ${d.target.id}`);
            
            node.append("title")
                .text(d => `${d.id} (${d.dynasty})`);

            // Tick 函数：更新元素位置
            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            }

            // 拖拽函数
            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    // event.subject.fx = null; // 释放固定位置
                    // event.subject.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }

        async function fetchRelationships() {
            try {
                const response = await fetch(`${API_BASE_URL}/relationships`);
                const result = await response.json();

                if (result.code === 200) {
                    renderRelationshipGraph(result.data);
                    showMessage('诗人关系图谱数据加载成功。', 'success');
                } else {
                    showMessage(`获取图谱数据失败: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Fetch relationships failed:', error);
                showMessage('网络错误，无法加载关系图谱数据。', 'error');
            }
        }


        // --- 8. 启动应用 ---
        document.addEventListener('DOMContentLoaded', () => {
            // 初始加载诗词列表
            fetchPoems();
            
            // 监听主评论表单提交
            document.getElementById('comment-form').addEventListener('submit', (event) => submitComment(event));
            
            // 监听搜索表单提交
            document.getElementById('search-form').addEventListener('submit', (event) => {
                event.preventDefault();
                const searchQuery = document.getElementById('search-query').value.trim();
                fetchPoems(searchQuery);
            });
            
            // **新增：监听清除搜索按钮点击**
            document.getElementById('clear-search-btn').addEventListener('click', () => {
                // 清空搜索状态，并加载全部数据
                document.getElementById('current-search-query').textContent = '';
                fetchPoems(); 
            });
        });

    </script>
</body>
</html>